#+begin_html
---
layout: post
title: "A really simple instrument"
date: 2012-10-16 09:26
comments: true
categories:
---
#+end_html

In this post we'll make a really basic =saw_synth= instrument. An
/instrument/ in Extempore allows you to trigger 'notes' like a MIDI
soft synth. [[file:./2012-09-28-making-an-instrument.org][This post]] goes into a lot more detail about how
Extempore's instrument infrastructure works, but this is more of a
'quick and dirty' example instrument just to get a feel for things.

All the instrument code is just regular [[file:./2012-08-09-xtlang-type-reference.org][xtlang]], and can be found in
=libs/core/instruments.xtm= and =libs/external/instruments.xtm=.

* A saw-synth note kernel

An instrument is basically two xtlang closures: a *note kernel
closure* and an *fx closure*.  These closures must have specific type
signatures to play nice with the instrument signal chain.

First, let's examine the note kernel closure. This closure takes
/zero/ arguments, and returns another closure which takes four
arguments:

- =time=: the current (sample) time in Extempore
- =chan=: the channel number
- =freq=: the frequency (pitch) of the note
- =amp=: the volume/loudness of the note

In an [[file:./2012-10-03-xtlang-type-diagrams.org][xtlang type diagram]]:

#+begin_html
<a href=""><img src="images/simple-instrument/note-kernel.png" width="300px" alt=""></a>
#+end_html

The /returned/ closure will be called to provide the basic audio
signal for the note, so that's where we put our code to generate the
saw wave

#+begin_src extempore
  (load "libs/core/instruments.xtm")
  
  (bind-func saw_synth_note_c
    (lambda ()
      (let ((saw (saw_c)))
        (lambda (time:double chan:double freq:double amp:double)
          (if (= chan 0.0)
              (saw amp freq)
              0.0)))))
  
  ;; when we evaluate saw_synth_note_c, the compiler prints:
  ;; Compiled saw_synth_note_c >>> [[double,double,double,double,double]*]*
#+end_src

Notice that the saw [[http://en.wikipedia.org/wiki/Unit_generator][unit-generator]] (ugen) =saw= is bound (by calling
=saw_c= [fn:csuffix]) /outside/ the inner =lambda= form. This inner
=lambda= defines the closure which will be /returned/ by
=saw_synth_note_c=. In this returned closure, the ugen =saw= (which is
itself an xtlang closure) is called with the amplitude and frequency
values which are passed in as arguments to the =lambda= form.  The
value returned by the =saw= closure (as it is called repeatedly, once
per audio sample) will trace out a [[http://en.wikipedia.org/wiki/Sawtooth_wave][sawtooth wave]].

This is just a mono note kernel at this stage---=saw= is only called
when =chan= is equal to =0.0=. The note kernel closure will actually
be called one for /each/ output channel, and the =chan= argument will
range from =0.0= for the first output channel to =(n-1).0= for the nth
output channel (the number of output channels you have will depend on
your audio device). It's therefore easy to generalise our note kernel
to multiple channels, so let's make it a stereo note kernel

#+begin_src extempore
  (bind-func saw_synth_note_c
    (lambda ()
      (let ((sawl (saw_c))
            (sawr (saw_c)))
        (lambda (time:double chan:double freq:double amp:double)
          (cond ((= chan 0.0)
                 (sawl amp freq))
                ((= chan 1.0)
                 (sawr amp freq))
                (else 0.0))))))
#+end_src

Now we make two saw ugens (=sawl= and =sawr=), and call the
appropriate one depending on the =chan= argument.  Our stereo saw note
kernel is now ready to play!

* Adding fx to the instrument

Often, you'll want to add an audio effect to the instrument's
output---maybe a delay, a reverb, or some more outlandish audio
processing.  But we don't want to apply the fx processing to each note
individually, but rather to the total audio output of the instrument.
And that's where the *fx closure* comes in.

#+begin_html
<a href=""><img src="images/simple-instrument/fx.png" width="300px" alt=""></a>
#+end_html

The most important argument to the fx closure is the =in= argument,
which represents the (dry) input signal that you want to process.  It
/is/ necessary to have an fx closure in your Extempore instrument,
although it may just pass its input through untouched:

#+begin_src extempore
  (bind-func saw_synth_fx
    (lambda (in:double time:double chan:double dat:double*)
      in))
  
  ;; when we evaluate saw_synth_fx, the compiler prints:  
  ;; Compiled saw_synth_fx >>> [double,double,double,double,double*]*
#+end_src

Let's add a stereo delay to make things a bit more interesting

#+begin_src extempore
  (bind-func saw_synth_fx 50000 ;; extra memory for the delay lines
    (let (((delayl (delay_c 22050))
           (delayr (delay_c 22050))))
      (lambda (in:double time:double chan:double dat:double*)
        (cond ((= chan 0.0)
               (delayl in))
              ((= chan 1.0)
               (delayr in))
              (else 0.0)))))
#+end_src

Nice one. Also, remember that you change the fx closure at any time
(just edit the code and [[file:./2012-09-26-interacting-with-the-extempore-compiler.org][re-evaluate it]]).

* Putting it all together

Finally, to complete the instrument, we use a special
=define-instrument= macro

#+begin_src extempore
  (define-instrument saw_synth saw_synth_note_c saw_synth_fx)
#+end_src

#+begin_html
<a href=""><img src="images/simple-instrument/whole-instrument.png" alt=""></a>
#+end_html

As long as your kernel (=saw_synth_note_c=) and fx (=saw_synth_fx=)
closures have the right signature, then evaluating the above line
should print for you

#+begin_example 
  Compiled saw_synth >>> [double,double,double,double,double*]*
#+end_example

...and now your instrument is ready to play.

What---is that the end?  Well, that's a bit frustrating: we haven't
even got to /play/ our instrument yet!  Don't worry---we'll use our
=saw_synth= instrument in this post about 'making it go bing'.

There are a couple of things to note which might be helpful for when
you want to build your /own/ instruments

- The note kernel closure (in this example =saw_synth_note_c=) returns
  a closure for each note: multiple notes may be playing
  simultaneously (polyphony), so you want to make sure that each
  closure keeps track of the state it needs and doesn't leak that
  state to any of the other notes which are playing simultaneously.
- Each note kernel returns it's output /one sample at a time/.  So it's
  up to you to make sure that these samples (when streamed to the
  audio hardware as an audio signal) make the audio waveform you're after.

And again, if you're interested in a more in-depth explanation of
Extempore's instrument infrastructure, then you can [[file:./2012-09-28-making-an-instrument.org][go and build your
own tonewheel organ]].

[fn:csuffix] By [[file:./2012-10-15-xtlang-naming-conventions.org][convention]], xtlang closures which /return/ closures
have a =_c= suffix.
